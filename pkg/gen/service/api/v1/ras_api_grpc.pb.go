// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package apiv1

import (
	context "context"
	v1 "github.com/v8platform/protos/gen/ras/messages/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AuthServiceClient is the client API for AuthService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthServiceClient interface {
	AuthenticateCluster(ctx context.Context, in *v1.ClusterAuthenticateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AuthenticateInfobase(ctx context.Context, in *v1.AuthenticateInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AuthenticateAgent(ctx context.Context, in *v1.ServerAuthenticateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type authServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthServiceClient(cc grpc.ClientConnInterface) AuthServiceClient {
	return &authServiceClient{cc}
}

func (c *authServiceClient) AuthenticateCluster(ctx context.Context, in *v1.ClusterAuthenticateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.AuthService/AuthenticateCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) AuthenticateInfobase(ctx context.Context, in *v1.AuthenticateInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.AuthService/AuthenticateInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authServiceClient) AuthenticateAgent(ctx context.Context, in *v1.ServerAuthenticateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.AuthService/AuthenticateAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthServiceServer is the server API for AuthService service.
// All implementations must embed UnimplementedAuthServiceServer
// for forward compatibility
type AuthServiceServer interface {
	AuthenticateCluster(context.Context, *v1.ClusterAuthenticateRequest) (*emptypb.Empty, error)
	AuthenticateInfobase(context.Context, *v1.AuthenticateInfobaseRequest) (*emptypb.Empty, error)
	AuthenticateAgent(context.Context, *v1.ServerAuthenticateRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedAuthServiceServer()
}

// UnimplementedAuthServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAuthServiceServer struct {
}

func (UnimplementedAuthServiceServer) AuthenticateCluster(context.Context, *v1.ClusterAuthenticateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticateCluster not implemented")
}
func (UnimplementedAuthServiceServer) AuthenticateInfobase(context.Context, *v1.AuthenticateInfobaseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticateInfobase not implemented")
}
func (UnimplementedAuthServiceServer) AuthenticateAgent(context.Context, *v1.ServerAuthenticateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticateAgent not implemented")
}
func (UnimplementedAuthServiceServer) mustEmbedUnimplementedAuthServiceServer() {}

// UnsafeAuthServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthServiceServer will
// result in compilation errors.
type UnsafeAuthServiceServer interface {
	mustEmbedUnimplementedAuthServiceServer()
}

func RegisterAuthServiceServer(s grpc.ServiceRegistrar, srv AuthServiceServer) {
	s.RegisterService(&AuthService_ServiceDesc, srv)
}

func _AuthService_AuthenticateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ClusterAuthenticateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).AuthenticateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.AuthService/AuthenticateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).AuthenticateCluster(ctx, req.(*v1.ClusterAuthenticateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_AuthenticateInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.AuthenticateInfobaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).AuthenticateInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.AuthService/AuthenticateInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).AuthenticateInfobase(ctx, req.(*v1.AuthenticateInfobaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthService_AuthenticateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ServerAuthenticateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthServiceServer).AuthenticateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.AuthService/AuthenticateAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthServiceServer).AuthenticateAgent(ctx, req.(*v1.ServerAuthenticateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AuthService_ServiceDesc is the grpc.ServiceDesc for AuthService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AuthService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.AuthService",
	HandlerType: (*AuthServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AuthenticateCluster",
			Handler:    _AuthService_AuthenticateCluster_Handler,
		},
		{
			MethodName: "AuthenticateInfobase",
			Handler:    _AuthService_AuthenticateInfobase_Handler,
		},
		{
			MethodName: "AuthenticateAgent",
			Handler:    _AuthService_AuthenticateAgent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// SessionsServiceClient is the client API for SessionsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionsServiceClient interface {
	GetSessions(ctx context.Context, in *v1.GetSessionsRequest, opts ...grpc.CallOption) (*v1.GetSessionsResponse, error)
	GetInfobaseSessions(ctx context.Context, in *v1.GetInfobaseSessionsRequest, opts ...grpc.CallOption) (*v1.GetInfobaseSessionsResponse, error)
	TerminateSession(ctx context.Context, in *v1.TerminateSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionsServiceClient(cc grpc.ClientConnInterface) SessionsServiceClient {
	return &sessionsServiceClient{cc}
}

func (c *sessionsServiceClient) GetSessions(ctx context.Context, in *v1.GetSessionsRequest, opts ...grpc.CallOption) (*v1.GetSessionsResponse, error) {
	out := new(v1.GetSessionsResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.SessionsService/GetSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionsServiceClient) GetInfobaseSessions(ctx context.Context, in *v1.GetInfobaseSessionsRequest, opts ...grpc.CallOption) (*v1.GetInfobaseSessionsResponse, error) {
	out := new(v1.GetInfobaseSessionsResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.SessionsService/GetInfobaseSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionsServiceClient) TerminateSession(ctx context.Context, in *v1.TerminateSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.SessionsService/TerminateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionsServiceServer is the server API for SessionsService service.
// All implementations must embed UnimplementedSessionsServiceServer
// for forward compatibility
type SessionsServiceServer interface {
	GetSessions(context.Context, *v1.GetSessionsRequest) (*v1.GetSessionsResponse, error)
	GetInfobaseSessions(context.Context, *v1.GetInfobaseSessionsRequest) (*v1.GetInfobaseSessionsResponse, error)
	TerminateSession(context.Context, *v1.TerminateSessionRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedSessionsServiceServer()
}

// UnimplementedSessionsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSessionsServiceServer struct {
}

func (UnimplementedSessionsServiceServer) GetSessions(context.Context, *v1.GetSessionsRequest) (*v1.GetSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSessions not implemented")
}
func (UnimplementedSessionsServiceServer) GetInfobaseSessions(context.Context, *v1.GetInfobaseSessionsRequest) (*v1.GetInfobaseSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobaseSessions not implemented")
}
func (UnimplementedSessionsServiceServer) TerminateSession(context.Context, *v1.TerminateSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateSession not implemented")
}
func (UnimplementedSessionsServiceServer) mustEmbedUnimplementedSessionsServiceServer() {}

// UnsafeSessionsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionsServiceServer will
// result in compilation errors.
type UnsafeSessionsServiceServer interface {
	mustEmbedUnimplementedSessionsServiceServer()
}

func RegisterSessionsServiceServer(s grpc.ServiceRegistrar, srv SessionsServiceServer) {
	s.RegisterService(&SessionsService_ServiceDesc, srv)
}

func _SessionsService_GetSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionsServiceServer).GetSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.SessionsService/GetSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionsServiceServer).GetSessions(ctx, req.(*v1.GetSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionsService_GetInfobaseSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobaseSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionsServiceServer).GetInfobaseSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.SessionsService/GetInfobaseSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionsServiceServer).GetInfobaseSessions(ctx, req.(*v1.GetInfobaseSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SessionsService_TerminateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.TerminateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionsServiceServer).TerminateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.SessionsService/TerminateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionsServiceServer).TerminateSession(ctx, req.(*v1.TerminateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SessionsService_ServiceDesc is the grpc.ServiceDesc for SessionsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SessionsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.SessionsService",
	HandlerType: (*SessionsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSessions",
			Handler:    _SessionsService_GetSessions_Handler,
		},
		{
			MethodName: "GetInfobaseSessions",
			Handler:    _SessionsService_GetInfobaseSessions_Handler,
		},
		{
			MethodName: "TerminateSession",
			Handler:    _SessionsService_TerminateSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// InfobasesServiceClient is the client API for InfobasesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InfobasesServiceClient interface {
	GetInfobases(ctx context.Context, in *v1.GetInfobasesRequest, opts ...grpc.CallOption) (*v1.GetInfobasesResponse, error)
	GetInfobasesSummary(ctx context.Context, in *v1.GetInfobasesSummaryRequest, opts ...grpc.CallOption) (*v1.GetInfobasesSummaryResponse, error)
	GetInfobase(ctx context.Context, in *v1.GetInfobaseInfoRequest, opts ...grpc.CallOption) (*v1.GetInfobaseInfoResponse, error)
	CreateInfobase(ctx context.Context, in *v1.CreateInfobaseRequest, opts ...grpc.CallOption) (*v1.CreateInfobaseResponse, error)
	UpdateInfobase(ctx context.Context, in *v1.UpdateInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteInfobase(ctx context.Context, in *v1.DropInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateInfobaseSummary(ctx context.Context, in *v1.UpdateInfobaseSummaryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type infobasesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInfobasesServiceClient(cc grpc.ClientConnInterface) InfobasesServiceClient {
	return &infobasesServiceClient{cc}
}

func (c *infobasesServiceClient) GetInfobases(ctx context.Context, in *v1.GetInfobasesRequest, opts ...grpc.CallOption) (*v1.GetInfobasesResponse, error) {
	out := new(v1.GetInfobasesResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.InfobasesService/GetInfobases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesServiceClient) GetInfobasesSummary(ctx context.Context, in *v1.GetInfobasesSummaryRequest, opts ...grpc.CallOption) (*v1.GetInfobasesSummaryResponse, error) {
	out := new(v1.GetInfobasesSummaryResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.InfobasesService/GetInfobasesSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesServiceClient) GetInfobase(ctx context.Context, in *v1.GetInfobaseInfoRequest, opts ...grpc.CallOption) (*v1.GetInfobaseInfoResponse, error) {
	out := new(v1.GetInfobaseInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.InfobasesService/GetInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesServiceClient) CreateInfobase(ctx context.Context, in *v1.CreateInfobaseRequest, opts ...grpc.CallOption) (*v1.CreateInfobaseResponse, error) {
	out := new(v1.CreateInfobaseResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.InfobasesService/CreateInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesServiceClient) UpdateInfobase(ctx context.Context, in *v1.UpdateInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.InfobasesService/UpdateInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesServiceClient) DeleteInfobase(ctx context.Context, in *v1.DropInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.InfobasesService/DeleteInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesServiceClient) UpdateInfobaseSummary(ctx context.Context, in *v1.UpdateInfobaseSummaryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.InfobasesService/UpdateInfobaseSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfobasesServiceServer is the server API for InfobasesService service.
// All implementations must embed UnimplementedInfobasesServiceServer
// for forward compatibility
type InfobasesServiceServer interface {
	GetInfobases(context.Context, *v1.GetInfobasesRequest) (*v1.GetInfobasesResponse, error)
	GetInfobasesSummary(context.Context, *v1.GetInfobasesSummaryRequest) (*v1.GetInfobasesSummaryResponse, error)
	GetInfobase(context.Context, *v1.GetInfobaseInfoRequest) (*v1.GetInfobaseInfoResponse, error)
	CreateInfobase(context.Context, *v1.CreateInfobaseRequest) (*v1.CreateInfobaseResponse, error)
	UpdateInfobase(context.Context, *v1.UpdateInfobaseRequest) (*emptypb.Empty, error)
	DeleteInfobase(context.Context, *v1.DropInfobaseRequest) (*emptypb.Empty, error)
	UpdateInfobaseSummary(context.Context, *v1.UpdateInfobaseSummaryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInfobasesServiceServer()
}

// UnimplementedInfobasesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInfobasesServiceServer struct {
}

func (UnimplementedInfobasesServiceServer) GetInfobases(context.Context, *v1.GetInfobasesRequest) (*v1.GetInfobasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobases not implemented")
}
func (UnimplementedInfobasesServiceServer) GetInfobasesSummary(context.Context, *v1.GetInfobasesSummaryRequest) (*v1.GetInfobasesSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobasesSummary not implemented")
}
func (UnimplementedInfobasesServiceServer) GetInfobase(context.Context, *v1.GetInfobaseInfoRequest) (*v1.GetInfobaseInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobase not implemented")
}
func (UnimplementedInfobasesServiceServer) CreateInfobase(context.Context, *v1.CreateInfobaseRequest) (*v1.CreateInfobaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInfobase not implemented")
}
func (UnimplementedInfobasesServiceServer) UpdateInfobase(context.Context, *v1.UpdateInfobaseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInfobase not implemented")
}
func (UnimplementedInfobasesServiceServer) DeleteInfobase(context.Context, *v1.DropInfobaseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInfobase not implemented")
}
func (UnimplementedInfobasesServiceServer) UpdateInfobaseSummary(context.Context, *v1.UpdateInfobaseSummaryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInfobaseSummary not implemented")
}
func (UnimplementedInfobasesServiceServer) mustEmbedUnimplementedInfobasesServiceServer() {}

// UnsafeInfobasesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InfobasesServiceServer will
// result in compilation errors.
type UnsafeInfobasesServiceServer interface {
	mustEmbedUnimplementedInfobasesServiceServer()
}

func RegisterInfobasesServiceServer(s grpc.ServiceRegistrar, srv InfobasesServiceServer) {
	s.RegisterService(&InfobasesService_ServiceDesc, srv)
}

func _InfobasesService_GetInfobases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServiceServer).GetInfobases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.InfobasesService/GetInfobases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServiceServer).GetInfobases(ctx, req.(*v1.GetInfobasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfobasesService_GetInfobasesSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobasesSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServiceServer).GetInfobasesSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.InfobasesService/GetInfobasesSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServiceServer).GetInfobasesSummary(ctx, req.(*v1.GetInfobasesSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfobasesService_GetInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobaseInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServiceServer).GetInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.InfobasesService/GetInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServiceServer).GetInfobase(ctx, req.(*v1.GetInfobaseInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfobasesService_CreateInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.CreateInfobaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServiceServer).CreateInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.InfobasesService/CreateInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServiceServer).CreateInfobase(ctx, req.(*v1.CreateInfobaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfobasesService_UpdateInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.UpdateInfobaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServiceServer).UpdateInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.InfobasesService/UpdateInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServiceServer).UpdateInfobase(ctx, req.(*v1.UpdateInfobaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfobasesService_DeleteInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.DropInfobaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServiceServer).DeleteInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.InfobasesService/DeleteInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServiceServer).DeleteInfobase(ctx, req.(*v1.DropInfobaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InfobasesService_UpdateInfobaseSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.UpdateInfobaseSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServiceServer).UpdateInfobaseSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.InfobasesService/UpdateInfobaseSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServiceServer).UpdateInfobaseSummary(ctx, req.(*v1.UpdateInfobaseSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InfobasesService_ServiceDesc is the grpc.ServiceDesc for InfobasesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InfobasesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.InfobasesService",
	HandlerType: (*InfobasesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfobases",
			Handler:    _InfobasesService_GetInfobases_Handler,
		},
		{
			MethodName: "GetInfobasesSummary",
			Handler:    _InfobasesService_GetInfobasesSummary_Handler,
		},
		{
			MethodName: "GetInfobase",
			Handler:    _InfobasesService_GetInfobase_Handler,
		},
		{
			MethodName: "CreateInfobase",
			Handler:    _InfobasesService_CreateInfobase_Handler,
		},
		{
			MethodName: "UpdateInfobase",
			Handler:    _InfobasesService_UpdateInfobase_Handler,
		},
		{
			MethodName: "DeleteInfobase",
			Handler:    _InfobasesService_DeleteInfobase_Handler,
		},
		{
			MethodName: "UpdateInfobaseSummary",
			Handler:    _InfobasesService_UpdateInfobaseSummary_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// ClustersServiceClient is the client API for ClustersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClustersServiceClient interface {
	GetClusters(ctx context.Context, in *v1.GetClustersRequest, opts ...grpc.CallOption) (*v1.GetClustersResponse, error)
	GetClusterInfo(ctx context.Context, in *v1.GetClusterInfoRequest, opts ...grpc.CallOption) (*v1.GetClusterInfoResponse, error)
	RegCluster(ctx context.Context, in *v1.RegClusterRequest, opts ...grpc.CallOption) (*v1.RegClusterResponse, error)
	UnregCluster(ctx context.Context, in *v1.UnregClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type clustersServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewClustersServiceClient(cc grpc.ClientConnInterface) ClustersServiceClient {
	return &clustersServiceClient{cc}
}

func (c *clustersServiceClient) GetClusters(ctx context.Context, in *v1.GetClustersRequest, opts ...grpc.CallOption) (*v1.GetClustersResponse, error) {
	out := new(v1.GetClustersResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ClustersService/GetClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clustersServiceClient) GetClusterInfo(ctx context.Context, in *v1.GetClusterInfoRequest, opts ...grpc.CallOption) (*v1.GetClusterInfoResponse, error) {
	out := new(v1.GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ClustersService/GetClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clustersServiceClient) RegCluster(ctx context.Context, in *v1.RegClusterRequest, opts ...grpc.CallOption) (*v1.RegClusterResponse, error) {
	out := new(v1.RegClusterResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ClustersService/RegCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clustersServiceClient) UnregCluster(ctx context.Context, in *v1.UnregClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.ClustersService/UnregCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClustersServiceServer is the server API for ClustersService service.
// All implementations must embed UnimplementedClustersServiceServer
// for forward compatibility
type ClustersServiceServer interface {
	GetClusters(context.Context, *v1.GetClustersRequest) (*v1.GetClustersResponse, error)
	GetClusterInfo(context.Context, *v1.GetClusterInfoRequest) (*v1.GetClusterInfoResponse, error)
	RegCluster(context.Context, *v1.RegClusterRequest) (*v1.RegClusterResponse, error)
	UnregCluster(context.Context, *v1.UnregClusterRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedClustersServiceServer()
}

// UnimplementedClustersServiceServer must be embedded to have forward compatible implementations.
type UnimplementedClustersServiceServer struct {
}

func (UnimplementedClustersServiceServer) GetClusters(context.Context, *v1.GetClustersRequest) (*v1.GetClustersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusters not implemented")
}
func (UnimplementedClustersServiceServer) GetClusterInfo(context.Context, *v1.GetClusterInfoRequest) (*v1.GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedClustersServiceServer) RegCluster(context.Context, *v1.RegClusterRequest) (*v1.RegClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegCluster not implemented")
}
func (UnimplementedClustersServiceServer) UnregCluster(context.Context, *v1.UnregClusterRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregCluster not implemented")
}
func (UnimplementedClustersServiceServer) mustEmbedUnimplementedClustersServiceServer() {}

// UnsafeClustersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClustersServiceServer will
// result in compilation errors.
type UnsafeClustersServiceServer interface {
	mustEmbedUnimplementedClustersServiceServer()
}

func RegisterClustersServiceServer(s grpc.ServiceRegistrar, srv ClustersServiceServer) {
	s.RegisterService(&ClustersService_ServiceDesc, srv)
}

func _ClustersService_GetClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClustersServiceServer).GetClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ClustersService/GetClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClustersServiceServer).GetClusters(ctx, req.(*v1.GetClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClustersService_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClustersServiceServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ClustersService/GetClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClustersServiceServer).GetClusterInfo(ctx, req.(*v1.GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClustersService_RegCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.RegClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClustersServiceServer).RegCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ClustersService/RegCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClustersServiceServer).RegCluster(ctx, req.(*v1.RegClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClustersService_UnregCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.UnregClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClustersServiceServer).UnregCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ClustersService/UnregCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClustersServiceServer).UnregCluster(ctx, req.(*v1.UnregClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ClustersService_ServiceDesc is the grpc.ServiceDesc for ClustersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ClustersService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.ClustersService",
	HandlerType: (*ClustersServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusters",
			Handler:    _ClustersService_GetClusters_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _ClustersService_GetClusterInfo_Handler,
		},
		{
			MethodName: "RegCluster",
			Handler:    _ClustersService_RegCluster_Handler,
		},
		{
			MethodName: "UnregCluster",
			Handler:    _ClustersService_UnregCluster_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// ManagersServiceClient is the client API for ManagersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagersServiceClient interface {
	GetClusterManagers(ctx context.Context, in *v1.GetClusterManagersRequest, opts ...grpc.CallOption) (*v1.GetClusterManagersResponse, error)
	GetClusterManagerInfo(ctx context.Context, in *v1.GetClusterManagerInfoRequest, opts ...grpc.CallOption) (*v1.GetClusterManagerInfoResponse, error)
}

type managersServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewManagersServiceClient(cc grpc.ClientConnInterface) ManagersServiceClient {
	return &managersServiceClient{cc}
}

func (c *managersServiceClient) GetClusterManagers(ctx context.Context, in *v1.GetClusterManagersRequest, opts ...grpc.CallOption) (*v1.GetClusterManagersResponse, error) {
	out := new(v1.GetClusterManagersResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ManagersService/GetClusterManagers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersServiceClient) GetClusterManagerInfo(ctx context.Context, in *v1.GetClusterManagerInfoRequest, opts ...grpc.CallOption) (*v1.GetClusterManagerInfoResponse, error) {
	out := new(v1.GetClusterManagerInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ManagersService/GetClusterManagerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagersServiceServer is the server API for ManagersService service.
// All implementations must embed UnimplementedManagersServiceServer
// for forward compatibility
type ManagersServiceServer interface {
	GetClusterManagers(context.Context, *v1.GetClusterManagersRequest) (*v1.GetClusterManagersResponse, error)
	GetClusterManagerInfo(context.Context, *v1.GetClusterManagerInfoRequest) (*v1.GetClusterManagerInfoResponse, error)
	mustEmbedUnimplementedManagersServiceServer()
}

// UnimplementedManagersServiceServer must be embedded to have forward compatible implementations.
type UnimplementedManagersServiceServer struct {
}

func (UnimplementedManagersServiceServer) GetClusterManagers(context.Context, *v1.GetClusterManagersRequest) (*v1.GetClusterManagersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterManagers not implemented")
}
func (UnimplementedManagersServiceServer) GetClusterManagerInfo(context.Context, *v1.GetClusterManagerInfoRequest) (*v1.GetClusterManagerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterManagerInfo not implemented")
}
func (UnimplementedManagersServiceServer) mustEmbedUnimplementedManagersServiceServer() {}

// UnsafeManagersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagersServiceServer will
// result in compilation errors.
type UnsafeManagersServiceServer interface {
	mustEmbedUnimplementedManagersServiceServer()
}

func RegisterManagersServiceServer(s grpc.ServiceRegistrar, srv ManagersServiceServer) {
	s.RegisterService(&ManagersService_ServiceDesc, srv)
}

func _ManagersService_GetClusterManagers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetClusterManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServiceServer).GetClusterManagers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ManagersService/GetClusterManagers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServiceServer).GetClusterManagers(ctx, req.(*v1.GetClusterManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ManagersService_GetClusterManagerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetClusterManagerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServiceServer).GetClusterManagerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ManagersService/GetClusterManagerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServiceServer).GetClusterManagerInfo(ctx, req.(*v1.GetClusterManagerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ManagersService_ServiceDesc is the grpc.ServiceDesc for ManagersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ManagersService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.ManagersService",
	HandlerType: (*ManagersServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusterManagers",
			Handler:    _ManagersService_GetClusterManagers_Handler,
		},
		{
			MethodName: "GetClusterManagerInfo",
			Handler:    _ManagersService_GetClusterManagerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// ProcessesServiceClient is the client API for ProcessesService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProcessesServiceClient interface {
	GetWorkingProcesses(ctx context.Context, in *v1.GetWorkingProcessesRequest, opts ...grpc.CallOption) (*v1.GetWorkingProcessesResponse, error)
	GetServerWorkingProcesses(ctx context.Context, in *v1.GetServerWorkingProcessesRequest, opts ...grpc.CallOption) (*v1.GetServerWorkingProcessesResponse, error)
	GetWorkingProcessInfo(ctx context.Context, in *v1.GetWorkingProcessInfoRequest, opts ...grpc.CallOption) (*v1.GetWorkingProcessInfoResponse, error)
}

type processesServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessesServiceClient(cc grpc.ClientConnInterface) ProcessesServiceClient {
	return &processesServiceClient{cc}
}

func (c *processesServiceClient) GetWorkingProcesses(ctx context.Context, in *v1.GetWorkingProcessesRequest, opts ...grpc.CallOption) (*v1.GetWorkingProcessesResponse, error) {
	out := new(v1.GetWorkingProcessesResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ProcessesService/GetWorkingProcesses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processesServiceClient) GetServerWorkingProcesses(ctx context.Context, in *v1.GetServerWorkingProcessesRequest, opts ...grpc.CallOption) (*v1.GetServerWorkingProcessesResponse, error) {
	out := new(v1.GetServerWorkingProcessesResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ProcessesService/GetServerWorkingProcesses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processesServiceClient) GetWorkingProcessInfo(ctx context.Context, in *v1.GetWorkingProcessInfoRequest, opts ...grpc.CallOption) (*v1.GetWorkingProcessInfoResponse, error) {
	out := new(v1.GetWorkingProcessInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ProcessesService/GetWorkingProcessInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessesServiceServer is the server API for ProcessesService service.
// All implementations must embed UnimplementedProcessesServiceServer
// for forward compatibility
type ProcessesServiceServer interface {
	GetWorkingProcesses(context.Context, *v1.GetWorkingProcessesRequest) (*v1.GetWorkingProcessesResponse, error)
	GetServerWorkingProcesses(context.Context, *v1.GetServerWorkingProcessesRequest) (*v1.GetServerWorkingProcessesResponse, error)
	GetWorkingProcessInfo(context.Context, *v1.GetWorkingProcessInfoRequest) (*v1.GetWorkingProcessInfoResponse, error)
	mustEmbedUnimplementedProcessesServiceServer()
}

// UnimplementedProcessesServiceServer must be embedded to have forward compatible implementations.
type UnimplementedProcessesServiceServer struct {
}

func (UnimplementedProcessesServiceServer) GetWorkingProcesses(context.Context, *v1.GetWorkingProcessesRequest) (*v1.GetWorkingProcessesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkingProcesses not implemented")
}
func (UnimplementedProcessesServiceServer) GetServerWorkingProcesses(context.Context, *v1.GetServerWorkingProcessesRequest) (*v1.GetServerWorkingProcessesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerWorkingProcesses not implemented")
}
func (UnimplementedProcessesServiceServer) GetWorkingProcessInfo(context.Context, *v1.GetWorkingProcessInfoRequest) (*v1.GetWorkingProcessInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkingProcessInfo not implemented")
}
func (UnimplementedProcessesServiceServer) mustEmbedUnimplementedProcessesServiceServer() {}

// UnsafeProcessesServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessesServiceServer will
// result in compilation errors.
type UnsafeProcessesServiceServer interface {
	mustEmbedUnimplementedProcessesServiceServer()
}

func RegisterProcessesServiceServer(s grpc.ServiceRegistrar, srv ProcessesServiceServer) {
	s.RegisterService(&ProcessesService_ServiceDesc, srv)
}

func _ProcessesService_GetWorkingProcesses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetWorkingProcessesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessesServiceServer).GetWorkingProcesses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ProcessesService/GetWorkingProcesses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessesServiceServer).GetWorkingProcesses(ctx, req.(*v1.GetWorkingProcessesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessesService_GetServerWorkingProcesses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetServerWorkingProcessesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessesServiceServer).GetServerWorkingProcesses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ProcessesService/GetServerWorkingProcesses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessesServiceServer).GetServerWorkingProcesses(ctx, req.(*v1.GetServerWorkingProcessesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessesService_GetWorkingProcessInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetWorkingProcessInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessesServiceServer).GetWorkingProcessInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ProcessesService/GetWorkingProcessInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessesServiceServer).GetWorkingProcessInfo(ctx, req.(*v1.GetWorkingProcessInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProcessesService_ServiceDesc is the grpc.ServiceDesc for ProcessesService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProcessesService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.ProcessesService",
	HandlerType: (*ProcessesServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWorkingProcesses",
			Handler:    _ProcessesService_GetWorkingProcesses_Handler,
		},
		{
			MethodName: "GetServerWorkingProcesses",
			Handler:    _ProcessesService_GetServerWorkingProcesses_Handler,
		},
		{
			MethodName: "GetWorkingProcessInfo",
			Handler:    _ProcessesService_GetWorkingProcessInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// ServersServiceClient is the client API for ServersService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServersServiceClient interface {
	GetWorkingServers(ctx context.Context, in *v1.GetWorkingServersRequest, opts ...grpc.CallOption) (*v1.GetWorkingServersResponse, error)
	GetWorkingServerInfo(ctx context.Context, in *v1.GetWorkingServerInfoRequest, opts ...grpc.CallOption) (*v1.GetWorkingServerInfoResponse, error)
	AddWorkingServer(ctx context.Context, in *v1.AddWorkingServerRequest, opts ...grpc.CallOption) (*v1.AddWorkingServerResponse, error)
	DeleteWorkingServer(ctx context.Context, in *v1.DeleteWorkingServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type serversServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewServersServiceClient(cc grpc.ClientConnInterface) ServersServiceClient {
	return &serversServiceClient{cc}
}

func (c *serversServiceClient) GetWorkingServers(ctx context.Context, in *v1.GetWorkingServersRequest, opts ...grpc.CallOption) (*v1.GetWorkingServersResponse, error) {
	out := new(v1.GetWorkingServersResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ServersService/GetWorkingServers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serversServiceClient) GetWorkingServerInfo(ctx context.Context, in *v1.GetWorkingServerInfoRequest, opts ...grpc.CallOption) (*v1.GetWorkingServerInfoResponse, error) {
	out := new(v1.GetWorkingServerInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ServersService/GetWorkingServerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serversServiceClient) AddWorkingServer(ctx context.Context, in *v1.AddWorkingServerRequest, opts ...grpc.CallOption) (*v1.AddWorkingServerResponse, error) {
	out := new(v1.AddWorkingServerResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.ServersService/AddWorkingServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serversServiceClient) DeleteWorkingServer(ctx context.Context, in *v1.DeleteWorkingServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.ServersService/DeleteWorkingServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServersServiceServer is the server API for ServersService service.
// All implementations must embed UnimplementedServersServiceServer
// for forward compatibility
type ServersServiceServer interface {
	GetWorkingServers(context.Context, *v1.GetWorkingServersRequest) (*v1.GetWorkingServersResponse, error)
	GetWorkingServerInfo(context.Context, *v1.GetWorkingServerInfoRequest) (*v1.GetWorkingServerInfoResponse, error)
	AddWorkingServer(context.Context, *v1.AddWorkingServerRequest) (*v1.AddWorkingServerResponse, error)
	DeleteWorkingServer(context.Context, *v1.DeleteWorkingServerRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedServersServiceServer()
}

// UnimplementedServersServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServersServiceServer struct {
}

func (UnimplementedServersServiceServer) GetWorkingServers(context.Context, *v1.GetWorkingServersRequest) (*v1.GetWorkingServersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkingServers not implemented")
}
func (UnimplementedServersServiceServer) GetWorkingServerInfo(context.Context, *v1.GetWorkingServerInfoRequest) (*v1.GetWorkingServerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkingServerInfo not implemented")
}
func (UnimplementedServersServiceServer) AddWorkingServer(context.Context, *v1.AddWorkingServerRequest) (*v1.AddWorkingServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWorkingServer not implemented")
}
func (UnimplementedServersServiceServer) DeleteWorkingServer(context.Context, *v1.DeleteWorkingServerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkingServer not implemented")
}
func (UnimplementedServersServiceServer) mustEmbedUnimplementedServersServiceServer() {}

// UnsafeServersServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServersServiceServer will
// result in compilation errors.
type UnsafeServersServiceServer interface {
	mustEmbedUnimplementedServersServiceServer()
}

func RegisterServersServiceServer(s grpc.ServiceRegistrar, srv ServersServiceServer) {
	s.RegisterService(&ServersService_ServiceDesc, srv)
}

func _ServersService_GetWorkingServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetWorkingServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServersServiceServer).GetWorkingServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ServersService/GetWorkingServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServersServiceServer).GetWorkingServers(ctx, req.(*v1.GetWorkingServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServersService_GetWorkingServerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetWorkingServerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServersServiceServer).GetWorkingServerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ServersService/GetWorkingServerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServersServiceServer).GetWorkingServerInfo(ctx, req.(*v1.GetWorkingServerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServersService_AddWorkingServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.AddWorkingServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServersServiceServer).AddWorkingServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ServersService/AddWorkingServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServersServiceServer).AddWorkingServer(ctx, req.(*v1.AddWorkingServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServersService_DeleteWorkingServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.DeleteWorkingServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServersServiceServer).DeleteWorkingServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.ServersService/DeleteWorkingServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServersServiceServer).DeleteWorkingServer(ctx, req.(*v1.DeleteWorkingServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ServersService_ServiceDesc is the grpc.ServiceDesc for ServersService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServersService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.ServersService",
	HandlerType: (*ServersServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWorkingServers",
			Handler:    _ServersService_GetWorkingServers_Handler,
		},
		{
			MethodName: "GetWorkingServerInfo",
			Handler:    _ServersService_GetWorkingServerInfo_Handler,
		},
		{
			MethodName: "AddWorkingServer",
			Handler:    _ServersService_AddWorkingServer_Handler,
		},
		{
			MethodName: "DeleteWorkingServer",
			Handler:    _ServersService_DeleteWorkingServer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}
