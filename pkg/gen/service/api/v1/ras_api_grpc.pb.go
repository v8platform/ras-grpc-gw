// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package apiv1

import (
	context "context"
	v1 "github.com/v8platform/protos/gen/ras/messages/v1"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// AuthorizationsClient is the client API for Authorizations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AuthorizationsClient interface {
	AuthenticateCluster(ctx context.Context, in *v1.ClusterAuthenticateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AuthenticateInfobase(ctx context.Context, in *v1.AuthenticateInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AuthenticateAgent(ctx context.Context, in *v1.ServerAuthenticateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type authorizationsClient struct {
	cc grpc.ClientConnInterface
}

func NewAuthorizationsClient(cc grpc.ClientConnInterface) AuthorizationsClient {
	return &authorizationsClient{cc}
}

func (c *authorizationsClient) AuthenticateCluster(ctx context.Context, in *v1.ClusterAuthenticateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Authorizations/AuthenticateCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorizationsClient) AuthenticateInfobase(ctx context.Context, in *v1.AuthenticateInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Authorizations/AuthenticateInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authorizationsClient) AuthenticateAgent(ctx context.Context, in *v1.ServerAuthenticateRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Authorizations/AuthenticateAgent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AuthorizationsServer is the server API for Authorizations service.
// All implementations must embed UnimplementedAuthorizationsServer
// for forward compatibility
type AuthorizationsServer interface {
	AuthenticateCluster(context.Context, *v1.ClusterAuthenticateRequest) (*emptypb.Empty, error)
	AuthenticateInfobase(context.Context, *v1.AuthenticateInfobaseRequest) (*emptypb.Empty, error)
	AuthenticateAgent(context.Context, *v1.ServerAuthenticateRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedAuthorizationsServer()
}

// UnimplementedAuthorizationsServer must be embedded to have forward compatible implementations.
type UnimplementedAuthorizationsServer struct {
}

func (UnimplementedAuthorizationsServer) AuthenticateCluster(context.Context, *v1.ClusterAuthenticateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticateCluster not implemented")
}
func (UnimplementedAuthorizationsServer) AuthenticateInfobase(context.Context, *v1.AuthenticateInfobaseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticateInfobase not implemented")
}
func (UnimplementedAuthorizationsServer) AuthenticateAgent(context.Context, *v1.ServerAuthenticateRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthenticateAgent not implemented")
}
func (UnimplementedAuthorizationsServer) mustEmbedUnimplementedAuthorizationsServer() {}

// UnsafeAuthorizationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AuthorizationsServer will
// result in compilation errors.
type UnsafeAuthorizationsServer interface {
	mustEmbedUnimplementedAuthorizationsServer()
}

func RegisterAuthorizationsServer(s grpc.ServiceRegistrar, srv AuthorizationsServer) {
	s.RegisterService(&Authorizations_ServiceDesc, srv)
}

func _Authorizations_AuthenticateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ClusterAuthenticateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorizationsServer).AuthenticateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Authorizations/AuthenticateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorizationsServer).AuthenticateCluster(ctx, req.(*v1.ClusterAuthenticateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authorizations_AuthenticateInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.AuthenticateInfobaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorizationsServer).AuthenticateInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Authorizations/AuthenticateInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorizationsServer).AuthenticateInfobase(ctx, req.(*v1.AuthenticateInfobaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Authorizations_AuthenticateAgent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.ServerAuthenticateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthorizationsServer).AuthenticateAgent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Authorizations/AuthenticateAgent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthorizationsServer).AuthenticateAgent(ctx, req.(*v1.ServerAuthenticateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Authorizations_ServiceDesc is the grpc.ServiceDesc for Authorizations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Authorizations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.Authorizations",
	HandlerType: (*AuthorizationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AuthenticateCluster",
			Handler:    _Authorizations_AuthenticateCluster_Handler,
		},
		{
			MethodName: "AuthenticateInfobase",
			Handler:    _Authorizations_AuthenticateInfobase_Handler,
		},
		{
			MethodName: "AuthenticateAgent",
			Handler:    _Authorizations_AuthenticateAgent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// SessionsClient is the client API for Sessions service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SessionsClient interface {
	GetSessions(ctx context.Context, in *v1.GetSessionsRequest, opts ...grpc.CallOption) (*v1.GetSessionsResponse, error)
	GetInfobaseSessions(ctx context.Context, in *v1.GetInfobaseSessionsRequest, opts ...grpc.CallOption) (*v1.GetInfobaseSessionsResponse, error)
	TerminateSession(ctx context.Context, in *v1.TerminateSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sessionsClient struct {
	cc grpc.ClientConnInterface
}

func NewSessionsClient(cc grpc.ClientConnInterface) SessionsClient {
	return &sessionsClient{cc}
}

func (c *sessionsClient) GetSessions(ctx context.Context, in *v1.GetSessionsRequest, opts ...grpc.CallOption) (*v1.GetSessionsResponse, error) {
	out := new(v1.GetSessionsResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Sessions/GetSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionsClient) GetInfobaseSessions(ctx context.Context, in *v1.GetInfobaseSessionsRequest, opts ...grpc.CallOption) (*v1.GetInfobaseSessionsResponse, error) {
	out := new(v1.GetInfobaseSessionsResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Sessions/GetInfobaseSessions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sessionsClient) TerminateSession(ctx context.Context, in *v1.TerminateSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Sessions/TerminateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SessionsServer is the server API for Sessions service.
// All implementations must embed UnimplementedSessionsServer
// for forward compatibility
type SessionsServer interface {
	GetSessions(context.Context, *v1.GetSessionsRequest) (*v1.GetSessionsResponse, error)
	GetInfobaseSessions(context.Context, *v1.GetInfobaseSessionsRequest) (*v1.GetInfobaseSessionsResponse, error)
	TerminateSession(context.Context, *v1.TerminateSessionRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedSessionsServer()
}

// UnimplementedSessionsServer must be embedded to have forward compatible implementations.
type UnimplementedSessionsServer struct {
}

func (UnimplementedSessionsServer) GetSessions(context.Context, *v1.GetSessionsRequest) (*v1.GetSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSessions not implemented")
}
func (UnimplementedSessionsServer) GetInfobaseSessions(context.Context, *v1.GetInfobaseSessionsRequest) (*v1.GetInfobaseSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobaseSessions not implemented")
}
func (UnimplementedSessionsServer) TerminateSession(context.Context, *v1.TerminateSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TerminateSession not implemented")
}
func (UnimplementedSessionsServer) mustEmbedUnimplementedSessionsServer() {}

// UnsafeSessionsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SessionsServer will
// result in compilation errors.
type UnsafeSessionsServer interface {
	mustEmbedUnimplementedSessionsServer()
}

func RegisterSessionsServer(s grpc.ServiceRegistrar, srv SessionsServer) {
	s.RegisterService(&Sessions_ServiceDesc, srv)
}

func _Sessions_GetSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionsServer).GetSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Sessions/GetSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionsServer).GetSessions(ctx, req.(*v1.GetSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sessions_GetInfobaseSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobaseSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionsServer).GetInfobaseSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Sessions/GetInfobaseSessions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionsServer).GetInfobaseSessions(ctx, req.(*v1.GetInfobaseSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sessions_TerminateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.TerminateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SessionsServer).TerminateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Sessions/TerminateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SessionsServer).TerminateSession(ctx, req.(*v1.TerminateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Sessions_ServiceDesc is the grpc.ServiceDesc for Sessions service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Sessions_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.Sessions",
	HandlerType: (*SessionsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSessions",
			Handler:    _Sessions_GetSessions_Handler,
		},
		{
			MethodName: "GetInfobaseSessions",
			Handler:    _Sessions_GetInfobaseSessions_Handler,
		},
		{
			MethodName: "TerminateSession",
			Handler:    _Sessions_TerminateSession_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// InfobasesClient is the client API for Infobases service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InfobasesClient interface {
	GetInfobases(ctx context.Context, in *v1.GetInfobasesRequest, opts ...grpc.CallOption) (*v1.GetInfobasesResponse, error)
	GetInfobasesSummary(ctx context.Context, in *v1.GetInfobasesSummaryRequest, opts ...grpc.CallOption) (*v1.GetInfobasesSummaryResponse, error)
	GetInfobase(ctx context.Context, in *v1.GetInfobaseInfoRequest, opts ...grpc.CallOption) (*v1.GetInfobaseInfoResponse, error)
	CreateInfobase(ctx context.Context, in *v1.CreateInfobaseRequest, opts ...grpc.CallOption) (*v1.CreateInfobaseResponse, error)
	UpdateInfobase(ctx context.Context, in *v1.UpdateInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteInfobase(ctx context.Context, in *v1.DropInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateInfobaseSummary(ctx context.Context, in *v1.UpdateInfobaseSummaryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type infobasesClient struct {
	cc grpc.ClientConnInterface
}

func NewInfobasesClient(cc grpc.ClientConnInterface) InfobasesClient {
	return &infobasesClient{cc}
}

func (c *infobasesClient) GetInfobases(ctx context.Context, in *v1.GetInfobasesRequest, opts ...grpc.CallOption) (*v1.GetInfobasesResponse, error) {
	out := new(v1.GetInfobasesResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Infobases/GetInfobases", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesClient) GetInfobasesSummary(ctx context.Context, in *v1.GetInfobasesSummaryRequest, opts ...grpc.CallOption) (*v1.GetInfobasesSummaryResponse, error) {
	out := new(v1.GetInfobasesSummaryResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Infobases/GetInfobasesSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesClient) GetInfobase(ctx context.Context, in *v1.GetInfobaseInfoRequest, opts ...grpc.CallOption) (*v1.GetInfobaseInfoResponse, error) {
	out := new(v1.GetInfobaseInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Infobases/GetInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesClient) CreateInfobase(ctx context.Context, in *v1.CreateInfobaseRequest, opts ...grpc.CallOption) (*v1.CreateInfobaseResponse, error) {
	out := new(v1.CreateInfobaseResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Infobases/CreateInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesClient) UpdateInfobase(ctx context.Context, in *v1.UpdateInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Infobases/UpdateInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesClient) DeleteInfobase(ctx context.Context, in *v1.DropInfobaseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Infobases/DeleteInfobase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *infobasesClient) UpdateInfobaseSummary(ctx context.Context, in *v1.UpdateInfobaseSummaryRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Infobases/UpdateInfobaseSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InfobasesServer is the server API for Infobases service.
// All implementations must embed UnimplementedInfobasesServer
// for forward compatibility
type InfobasesServer interface {
	GetInfobases(context.Context, *v1.GetInfobasesRequest) (*v1.GetInfobasesResponse, error)
	GetInfobasesSummary(context.Context, *v1.GetInfobasesSummaryRequest) (*v1.GetInfobasesSummaryResponse, error)
	GetInfobase(context.Context, *v1.GetInfobaseInfoRequest) (*v1.GetInfobaseInfoResponse, error)
	CreateInfobase(context.Context, *v1.CreateInfobaseRequest) (*v1.CreateInfobaseResponse, error)
	UpdateInfobase(context.Context, *v1.UpdateInfobaseRequest) (*emptypb.Empty, error)
	DeleteInfobase(context.Context, *v1.DropInfobaseRequest) (*emptypb.Empty, error)
	UpdateInfobaseSummary(context.Context, *v1.UpdateInfobaseSummaryRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedInfobasesServer()
}

// UnimplementedInfobasesServer must be embedded to have forward compatible implementations.
type UnimplementedInfobasesServer struct {
}

func (UnimplementedInfobasesServer) GetInfobases(context.Context, *v1.GetInfobasesRequest) (*v1.GetInfobasesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobases not implemented")
}
func (UnimplementedInfobasesServer) GetInfobasesSummary(context.Context, *v1.GetInfobasesSummaryRequest) (*v1.GetInfobasesSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobasesSummary not implemented")
}
func (UnimplementedInfobasesServer) GetInfobase(context.Context, *v1.GetInfobaseInfoRequest) (*v1.GetInfobaseInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobase not implemented")
}
func (UnimplementedInfobasesServer) CreateInfobase(context.Context, *v1.CreateInfobaseRequest) (*v1.CreateInfobaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInfobase not implemented")
}
func (UnimplementedInfobasesServer) UpdateInfobase(context.Context, *v1.UpdateInfobaseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInfobase not implemented")
}
func (UnimplementedInfobasesServer) DeleteInfobase(context.Context, *v1.DropInfobaseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInfobase not implemented")
}
func (UnimplementedInfobasesServer) UpdateInfobaseSummary(context.Context, *v1.UpdateInfobaseSummaryRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInfobaseSummary not implemented")
}
func (UnimplementedInfobasesServer) mustEmbedUnimplementedInfobasesServer() {}

// UnsafeInfobasesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InfobasesServer will
// result in compilation errors.
type UnsafeInfobasesServer interface {
	mustEmbedUnimplementedInfobasesServer()
}

func RegisterInfobasesServer(s grpc.ServiceRegistrar, srv InfobasesServer) {
	s.RegisterService(&Infobases_ServiceDesc, srv)
}

func _Infobases_GetInfobases_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobasesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServer).GetInfobases(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Infobases/GetInfobases",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServer).GetInfobases(ctx, req.(*v1.GetInfobasesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Infobases_GetInfobasesSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobasesSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServer).GetInfobasesSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Infobases/GetInfobasesSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServer).GetInfobasesSummary(ctx, req.(*v1.GetInfobasesSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Infobases_GetInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobaseInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServer).GetInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Infobases/GetInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServer).GetInfobase(ctx, req.(*v1.GetInfobaseInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Infobases_CreateInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.CreateInfobaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServer).CreateInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Infobases/CreateInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServer).CreateInfobase(ctx, req.(*v1.CreateInfobaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Infobases_UpdateInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.UpdateInfobaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServer).UpdateInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Infobases/UpdateInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServer).UpdateInfobase(ctx, req.(*v1.UpdateInfobaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Infobases_DeleteInfobase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.DropInfobaseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServer).DeleteInfobase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Infobases/DeleteInfobase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServer).DeleteInfobase(ctx, req.(*v1.DropInfobaseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Infobases_UpdateInfobaseSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.UpdateInfobaseSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InfobasesServer).UpdateInfobaseSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Infobases/UpdateInfobaseSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InfobasesServer).UpdateInfobaseSummary(ctx, req.(*v1.UpdateInfobaseSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Infobases_ServiceDesc is the grpc.ServiceDesc for Infobases service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Infobases_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.Infobases",
	HandlerType: (*InfobasesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetInfobases",
			Handler:    _Infobases_GetInfobases_Handler,
		},
		{
			MethodName: "GetInfobasesSummary",
			Handler:    _Infobases_GetInfobasesSummary_Handler,
		},
		{
			MethodName: "GetInfobase",
			Handler:    _Infobases_GetInfobase_Handler,
		},
		{
			MethodName: "CreateInfobase",
			Handler:    _Infobases_CreateInfobase_Handler,
		},
		{
			MethodName: "UpdateInfobase",
			Handler:    _Infobases_UpdateInfobase_Handler,
		},
		{
			MethodName: "DeleteInfobase",
			Handler:    _Infobases_DeleteInfobase_Handler,
		},
		{
			MethodName: "UpdateInfobaseSummary",
			Handler:    _Infobases_UpdateInfobaseSummary_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// ClustersClient is the client API for Clusters service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ClustersClient interface {
	GetClusters(ctx context.Context, in *v1.GetClustersRequest, opts ...grpc.CallOption) (*v1.GetClustersResponse, error)
	GetClusterInfo(ctx context.Context, in *v1.GetClusterInfoRequest, opts ...grpc.CallOption) (*v1.GetClusterInfoResponse, error)
	RegCluster(ctx context.Context, in *v1.RegClusterRequest, opts ...grpc.CallOption) (*v1.RegClusterResponse, error)
	UnregCluster(ctx context.Context, in *v1.UnregClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type clustersClient struct {
	cc grpc.ClientConnInterface
}

func NewClustersClient(cc grpc.ClientConnInterface) ClustersClient {
	return &clustersClient{cc}
}

func (c *clustersClient) GetClusters(ctx context.Context, in *v1.GetClustersRequest, opts ...grpc.CallOption) (*v1.GetClustersResponse, error) {
	out := new(v1.GetClustersResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Clusters/GetClusters", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clustersClient) GetClusterInfo(ctx context.Context, in *v1.GetClusterInfoRequest, opts ...grpc.CallOption) (*v1.GetClusterInfoResponse, error) {
	out := new(v1.GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Clusters/GetClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clustersClient) RegCluster(ctx context.Context, in *v1.RegClusterRequest, opts ...grpc.CallOption) (*v1.RegClusterResponse, error) {
	out := new(v1.RegClusterResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Clusters/RegCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clustersClient) UnregCluster(ctx context.Context, in *v1.UnregClusterRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Clusters/UnregCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClustersServer is the server API for Clusters service.
// All implementations must embed UnimplementedClustersServer
// for forward compatibility
type ClustersServer interface {
	GetClusters(context.Context, *v1.GetClustersRequest) (*v1.GetClustersResponse, error)
	GetClusterInfo(context.Context, *v1.GetClusterInfoRequest) (*v1.GetClusterInfoResponse, error)
	RegCluster(context.Context, *v1.RegClusterRequest) (*v1.RegClusterResponse, error)
	UnregCluster(context.Context, *v1.UnregClusterRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedClustersServer()
}

// UnimplementedClustersServer must be embedded to have forward compatible implementations.
type UnimplementedClustersServer struct {
}

func (UnimplementedClustersServer) GetClusters(context.Context, *v1.GetClustersRequest) (*v1.GetClustersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusters not implemented")
}
func (UnimplementedClustersServer) GetClusterInfo(context.Context, *v1.GetClusterInfoRequest) (*v1.GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}
func (UnimplementedClustersServer) RegCluster(context.Context, *v1.RegClusterRequest) (*v1.RegClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegCluster not implemented")
}
func (UnimplementedClustersServer) UnregCluster(context.Context, *v1.UnregClusterRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregCluster not implemented")
}
func (UnimplementedClustersServer) mustEmbedUnimplementedClustersServer() {}

// UnsafeClustersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ClustersServer will
// result in compilation errors.
type UnsafeClustersServer interface {
	mustEmbedUnimplementedClustersServer()
}

func RegisterClustersServer(s grpc.ServiceRegistrar, srv ClustersServer) {
	s.RegisterService(&Clusters_ServiceDesc, srv)
}

func _Clusters_GetClusters_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetClustersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClustersServer).GetClusters(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Clusters/GetClusters",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClustersServer).GetClusters(ctx, req.(*v1.GetClustersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clusters_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClustersServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Clusters/GetClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClustersServer).GetClusterInfo(ctx, req.(*v1.GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clusters_RegCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.RegClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClustersServer).RegCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Clusters/RegCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClustersServer).RegCluster(ctx, req.(*v1.RegClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Clusters_UnregCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.UnregClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClustersServer).UnregCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Clusters/UnregCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClustersServer).UnregCluster(ctx, req.(*v1.UnregClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Clusters_ServiceDesc is the grpc.ServiceDesc for Clusters service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Clusters_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.Clusters",
	HandlerType: (*ClustersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusters",
			Handler:    _Clusters_GetClusters_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _Clusters_GetClusterInfo_Handler,
		},
		{
			MethodName: "RegCluster",
			Handler:    _Clusters_RegCluster_Handler,
		},
		{
			MethodName: "UnregCluster",
			Handler:    _Clusters_UnregCluster_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// ManagersClient is the client API for Managers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ManagersClient interface {
	GetClusterManagers(ctx context.Context, in *v1.GetClusterManagersRequest, opts ...grpc.CallOption) (*v1.GetClusterManagersResponse, error)
	GetClusterManagerInfo(ctx context.Context, in *v1.GetClusterManagerInfoRequest, opts ...grpc.CallOption) (*v1.GetClusterManagerInfoResponse, error)
}

type managersClient struct {
	cc grpc.ClientConnInterface
}

func NewManagersClient(cc grpc.ClientConnInterface) ManagersClient {
	return &managersClient{cc}
}

func (c *managersClient) GetClusterManagers(ctx context.Context, in *v1.GetClusterManagersRequest, opts ...grpc.CallOption) (*v1.GetClusterManagersResponse, error) {
	out := new(v1.GetClusterManagersResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Managers/GetClusterManagers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managersClient) GetClusterManagerInfo(ctx context.Context, in *v1.GetClusterManagerInfoRequest, opts ...grpc.CallOption) (*v1.GetClusterManagerInfoResponse, error) {
	out := new(v1.GetClusterManagerInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Managers/GetClusterManagerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagersServer is the server API for Managers service.
// All implementations must embed UnimplementedManagersServer
// for forward compatibility
type ManagersServer interface {
	GetClusterManagers(context.Context, *v1.GetClusterManagersRequest) (*v1.GetClusterManagersResponse, error)
	GetClusterManagerInfo(context.Context, *v1.GetClusterManagerInfoRequest) (*v1.GetClusterManagerInfoResponse, error)
	mustEmbedUnimplementedManagersServer()
}

// UnimplementedManagersServer must be embedded to have forward compatible implementations.
type UnimplementedManagersServer struct {
}

func (UnimplementedManagersServer) GetClusterManagers(context.Context, *v1.GetClusterManagersRequest) (*v1.GetClusterManagersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterManagers not implemented")
}
func (UnimplementedManagersServer) GetClusterManagerInfo(context.Context, *v1.GetClusterManagerInfoRequest) (*v1.GetClusterManagerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterManagerInfo not implemented")
}
func (UnimplementedManagersServer) mustEmbedUnimplementedManagersServer() {}

// UnsafeManagersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ManagersServer will
// result in compilation errors.
type UnsafeManagersServer interface {
	mustEmbedUnimplementedManagersServer()
}

func RegisterManagersServer(s grpc.ServiceRegistrar, srv ManagersServer) {
	s.RegisterService(&Managers_ServiceDesc, srv)
}

func _Managers_GetClusterManagers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetClusterManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).GetClusterManagers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Managers/GetClusterManagers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).GetClusterManagers(ctx, req.(*v1.GetClusterManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Managers_GetClusterManagerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetClusterManagerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagersServer).GetClusterManagerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Managers/GetClusterManagerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagersServer).GetClusterManagerInfo(ctx, req.(*v1.GetClusterManagerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Managers_ServiceDesc is the grpc.ServiceDesc for Managers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Managers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.Managers",
	HandlerType: (*ManagersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetClusterManagers",
			Handler:    _Managers_GetClusterManagers_Handler,
		},
		{
			MethodName: "GetClusterManagerInfo",
			Handler:    _Managers_GetClusterManagerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// ProcessesClient is the client API for Processes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProcessesClient interface {
	GetWorkingProcesses(ctx context.Context, in *v1.GetWorkingProcessesRequest, opts ...grpc.CallOption) (*v1.GetWorkingProcessesResponse, error)
	GetServerWorkingProcesses(ctx context.Context, in *v1.GetServerWorkingProcessesRequest, opts ...grpc.CallOption) (*v1.GetServerWorkingProcessesResponse, error)
	GetWorkingProcessInfo(ctx context.Context, in *v1.GetWorkingProcessInfoRequest, opts ...grpc.CallOption) (*v1.GetWorkingProcessInfoResponse, error)
}

type processesClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessesClient(cc grpc.ClientConnInterface) ProcessesClient {
	return &processesClient{cc}
}

func (c *processesClient) GetWorkingProcesses(ctx context.Context, in *v1.GetWorkingProcessesRequest, opts ...grpc.CallOption) (*v1.GetWorkingProcessesResponse, error) {
	out := new(v1.GetWorkingProcessesResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Processes/GetWorkingProcesses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processesClient) GetServerWorkingProcesses(ctx context.Context, in *v1.GetServerWorkingProcessesRequest, opts ...grpc.CallOption) (*v1.GetServerWorkingProcessesResponse, error) {
	out := new(v1.GetServerWorkingProcessesResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Processes/GetServerWorkingProcesses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processesClient) GetWorkingProcessInfo(ctx context.Context, in *v1.GetWorkingProcessInfoRequest, opts ...grpc.CallOption) (*v1.GetWorkingProcessInfoResponse, error) {
	out := new(v1.GetWorkingProcessInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Processes/GetWorkingProcessInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessesServer is the server API for Processes service.
// All implementations must embed UnimplementedProcessesServer
// for forward compatibility
type ProcessesServer interface {
	GetWorkingProcesses(context.Context, *v1.GetWorkingProcessesRequest) (*v1.GetWorkingProcessesResponse, error)
	GetServerWorkingProcesses(context.Context, *v1.GetServerWorkingProcessesRequest) (*v1.GetServerWorkingProcessesResponse, error)
	GetWorkingProcessInfo(context.Context, *v1.GetWorkingProcessInfoRequest) (*v1.GetWorkingProcessInfoResponse, error)
	mustEmbedUnimplementedProcessesServer()
}

// UnimplementedProcessesServer must be embedded to have forward compatible implementations.
type UnimplementedProcessesServer struct {
}

func (UnimplementedProcessesServer) GetWorkingProcesses(context.Context, *v1.GetWorkingProcessesRequest) (*v1.GetWorkingProcessesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkingProcesses not implemented")
}
func (UnimplementedProcessesServer) GetServerWorkingProcesses(context.Context, *v1.GetServerWorkingProcessesRequest) (*v1.GetServerWorkingProcessesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerWorkingProcesses not implemented")
}
func (UnimplementedProcessesServer) GetWorkingProcessInfo(context.Context, *v1.GetWorkingProcessInfoRequest) (*v1.GetWorkingProcessInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkingProcessInfo not implemented")
}
func (UnimplementedProcessesServer) mustEmbedUnimplementedProcessesServer() {}

// UnsafeProcessesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessesServer will
// result in compilation errors.
type UnsafeProcessesServer interface {
	mustEmbedUnimplementedProcessesServer()
}

func RegisterProcessesServer(s grpc.ServiceRegistrar, srv ProcessesServer) {
	s.RegisterService(&Processes_ServiceDesc, srv)
}

func _Processes_GetWorkingProcesses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetWorkingProcessesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessesServer).GetWorkingProcesses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Processes/GetWorkingProcesses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessesServer).GetWorkingProcesses(ctx, req.(*v1.GetWorkingProcessesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Processes_GetServerWorkingProcesses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetServerWorkingProcessesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessesServer).GetServerWorkingProcesses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Processes/GetServerWorkingProcesses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessesServer).GetServerWorkingProcesses(ctx, req.(*v1.GetServerWorkingProcessesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Processes_GetWorkingProcessInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetWorkingProcessInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessesServer).GetWorkingProcessInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Processes/GetWorkingProcessInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessesServer).GetWorkingProcessInfo(ctx, req.(*v1.GetWorkingProcessInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Processes_ServiceDesc is the grpc.ServiceDesc for Processes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Processes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.Processes",
	HandlerType: (*ProcessesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWorkingProcesses",
			Handler:    _Processes_GetWorkingProcesses_Handler,
		},
		{
			MethodName: "GetServerWorkingProcesses",
			Handler:    _Processes_GetServerWorkingProcesses_Handler,
		},
		{
			MethodName: "GetWorkingProcessInfo",
			Handler:    _Processes_GetWorkingProcessInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// ServersClient is the client API for Servers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServersClient interface {
	GetWorkingServers(ctx context.Context, in *v1.GetWorkingServersRequest, opts ...grpc.CallOption) (*v1.GetWorkingServersResponse, error)
	GetWorkingServerInfo(ctx context.Context, in *v1.GetWorkingServerInfoRequest, opts ...grpc.CallOption) (*v1.GetWorkingServerInfoResponse, error)
	AddWorkingServer(ctx context.Context, in *v1.AddWorkingServerRequest, opts ...grpc.CallOption) (*v1.AddWorkingServerResponse, error)
	DeleteWorkingServer(ctx context.Context, in *v1.DeleteWorkingServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type serversClient struct {
	cc grpc.ClientConnInterface
}

func NewServersClient(cc grpc.ClientConnInterface) ServersClient {
	return &serversClient{cc}
}

func (c *serversClient) GetWorkingServers(ctx context.Context, in *v1.GetWorkingServersRequest, opts ...grpc.CallOption) (*v1.GetWorkingServersResponse, error) {
	out := new(v1.GetWorkingServersResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Servers/GetWorkingServers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serversClient) GetWorkingServerInfo(ctx context.Context, in *v1.GetWorkingServerInfoRequest, opts ...grpc.CallOption) (*v1.GetWorkingServerInfoResponse, error) {
	out := new(v1.GetWorkingServerInfoResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Servers/GetWorkingServerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serversClient) AddWorkingServer(ctx context.Context, in *v1.AddWorkingServerRequest, opts ...grpc.CallOption) (*v1.AddWorkingServerResponse, error) {
	out := new(v1.AddWorkingServerResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Servers/AddWorkingServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serversClient) DeleteWorkingServer(ctx context.Context, in *v1.DeleteWorkingServerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Servers/DeleteWorkingServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServersServer is the server API for Servers service.
// All implementations must embed UnimplementedServersServer
// for forward compatibility
type ServersServer interface {
	GetWorkingServers(context.Context, *v1.GetWorkingServersRequest) (*v1.GetWorkingServersResponse, error)
	GetWorkingServerInfo(context.Context, *v1.GetWorkingServerInfoRequest) (*v1.GetWorkingServerInfoResponse, error)
	AddWorkingServer(context.Context, *v1.AddWorkingServerRequest) (*v1.AddWorkingServerResponse, error)
	DeleteWorkingServer(context.Context, *v1.DeleteWorkingServerRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedServersServer()
}

// UnimplementedServersServer must be embedded to have forward compatible implementations.
type UnimplementedServersServer struct {
}

func (UnimplementedServersServer) GetWorkingServers(context.Context, *v1.GetWorkingServersRequest) (*v1.GetWorkingServersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkingServers not implemented")
}
func (UnimplementedServersServer) GetWorkingServerInfo(context.Context, *v1.GetWorkingServerInfoRequest) (*v1.GetWorkingServerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWorkingServerInfo not implemented")
}
func (UnimplementedServersServer) AddWorkingServer(context.Context, *v1.AddWorkingServerRequest) (*v1.AddWorkingServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddWorkingServer not implemented")
}
func (UnimplementedServersServer) DeleteWorkingServer(context.Context, *v1.DeleteWorkingServerRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteWorkingServer not implemented")
}
func (UnimplementedServersServer) mustEmbedUnimplementedServersServer() {}

// UnsafeServersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServersServer will
// result in compilation errors.
type UnsafeServersServer interface {
	mustEmbedUnimplementedServersServer()
}

func RegisterServersServer(s grpc.ServiceRegistrar, srv ServersServer) {
	s.RegisterService(&Servers_ServiceDesc, srv)
}

func _Servers_GetWorkingServers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetWorkingServersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServersServer).GetWorkingServers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Servers/GetWorkingServers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServersServer).GetWorkingServers(ctx, req.(*v1.GetWorkingServersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Servers_GetWorkingServerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetWorkingServerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServersServer).GetWorkingServerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Servers/GetWorkingServerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServersServer).GetWorkingServerInfo(ctx, req.(*v1.GetWorkingServerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Servers_AddWorkingServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.AddWorkingServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServersServer).AddWorkingServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Servers/AddWorkingServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServersServer).AddWorkingServer(ctx, req.(*v1.AddWorkingServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Servers_DeleteWorkingServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.DeleteWorkingServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServersServer).DeleteWorkingServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Servers/DeleteWorkingServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServersServer).DeleteWorkingServer(ctx, req.(*v1.DeleteWorkingServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Servers_ServiceDesc is the grpc.ServiceDesc for Servers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Servers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.Servers",
	HandlerType: (*ServersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWorkingServers",
			Handler:    _Servers_GetWorkingServers_Handler,
		},
		{
			MethodName: "GetWorkingServerInfo",
			Handler:    _Servers_GetWorkingServerInfo_Handler,
		},
		{
			MethodName: "AddWorkingServer",
			Handler:    _Servers_AddWorkingServer_Handler,
		},
		{
			MethodName: "DeleteWorkingServer",
			Handler:    _Servers_DeleteWorkingServer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// ConnectionsClient is the client API for Connections service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConnectionsClient interface {
	GetConnections(ctx context.Context, in *v1.GetConnectionsRequest, opts ...grpc.CallOption) (*v1.GetConnectionsResponse, error)
	GetInfobaseConnections(ctx context.Context, in *v1.GetInfobaseConnectionsRequest, opts ...grpc.CallOption) (*v1.GetInfobaseConnectionsResponse, error)
	DisconnectConnection(ctx context.Context, in *v1.DisconnectConnectionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type connectionsClient struct {
	cc grpc.ClientConnInterface
}

func NewConnectionsClient(cc grpc.ClientConnInterface) ConnectionsClient {
	return &connectionsClient{cc}
}

func (c *connectionsClient) GetConnections(ctx context.Context, in *v1.GetConnectionsRequest, opts ...grpc.CallOption) (*v1.GetConnectionsResponse, error) {
	out := new(v1.GetConnectionsResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Connections/GetConnections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionsClient) GetInfobaseConnections(ctx context.Context, in *v1.GetInfobaseConnectionsRequest, opts ...grpc.CallOption) (*v1.GetInfobaseConnectionsResponse, error) {
	out := new(v1.GetInfobaseConnectionsResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Connections/GetInfobaseConnections", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectionsClient) DisconnectConnection(ctx context.Context, in *v1.DisconnectConnectionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/service.api.v1.Connections/DisconnectConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConnectionsServer is the server API for Connections service.
// All implementations must embed UnimplementedConnectionsServer
// for forward compatibility
type ConnectionsServer interface {
	GetConnections(context.Context, *v1.GetConnectionsRequest) (*v1.GetConnectionsResponse, error)
	GetInfobaseConnections(context.Context, *v1.GetInfobaseConnectionsRequest) (*v1.GetInfobaseConnectionsResponse, error)
	DisconnectConnection(context.Context, *v1.DisconnectConnectionRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedConnectionsServer()
}

// UnimplementedConnectionsServer must be embedded to have forward compatible implementations.
type UnimplementedConnectionsServer struct {
}

func (UnimplementedConnectionsServer) GetConnections(context.Context, *v1.GetConnectionsRequest) (*v1.GetConnectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnections not implemented")
}
func (UnimplementedConnectionsServer) GetInfobaseConnections(context.Context, *v1.GetInfobaseConnectionsRequest) (*v1.GetInfobaseConnectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobaseConnections not implemented")
}
func (UnimplementedConnectionsServer) DisconnectConnection(context.Context, *v1.DisconnectConnectionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisconnectConnection not implemented")
}
func (UnimplementedConnectionsServer) mustEmbedUnimplementedConnectionsServer() {}

// UnsafeConnectionsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConnectionsServer will
// result in compilation errors.
type UnsafeConnectionsServer interface {
	mustEmbedUnimplementedConnectionsServer()
}

func RegisterConnectionsServer(s grpc.ServiceRegistrar, srv ConnectionsServer) {
	s.RegisterService(&Connections_ServiceDesc, srv)
}

func _Connections_GetConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetConnectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionsServer).GetConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Connections/GetConnections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionsServer).GetConnections(ctx, req.(*v1.GetConnectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connections_GetInfobaseConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobaseConnectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionsServer).GetInfobaseConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Connections/GetInfobaseConnections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionsServer).GetInfobaseConnections(ctx, req.(*v1.GetInfobaseConnectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connections_DisconnectConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.DisconnectConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectionsServer).DisconnectConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Connections/DisconnectConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectionsServer).DisconnectConnection(ctx, req.(*v1.DisconnectConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Connections_ServiceDesc is the grpc.ServiceDesc for Connections service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Connections_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.Connections",
	HandlerType: (*ConnectionsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConnections",
			Handler:    _Connections_GetConnections_Handler,
		},
		{
			MethodName: "GetInfobaseConnections",
			Handler:    _Connections_GetInfobaseConnections_Handler,
		},
		{
			MethodName: "DisconnectConnection",
			Handler:    _Connections_DisconnectConnection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}

// LocksClient is the client API for Locks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LocksClient interface {
	GetLocks(ctx context.Context, in *v1.GetLocksRequest, opts ...grpc.CallOption) (*v1.GetLocksResponse, error)
	GetInfobaseLocks(ctx context.Context, in *v1.GetInfobaseLocksRequest, opts ...grpc.CallOption) (*v1.GetInfobaseLocksResponse, error)
	GetSessionLocks(ctx context.Context, in *v1.GetSessionLocksRequest, opts ...grpc.CallOption) (*v1.GetSessionLocksResponse, error)
	GetConnectionLocks(ctx context.Context, in *v1.GetConnectionLocksRequest, opts ...grpc.CallOption) (*v1.GetConnectionLocksResponse, error)
}

type locksClient struct {
	cc grpc.ClientConnInterface
}

func NewLocksClient(cc grpc.ClientConnInterface) LocksClient {
	return &locksClient{cc}
}

func (c *locksClient) GetLocks(ctx context.Context, in *v1.GetLocksRequest, opts ...grpc.CallOption) (*v1.GetLocksResponse, error) {
	out := new(v1.GetLocksResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Locks/GetLocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locksClient) GetInfobaseLocks(ctx context.Context, in *v1.GetInfobaseLocksRequest, opts ...grpc.CallOption) (*v1.GetInfobaseLocksResponse, error) {
	out := new(v1.GetInfobaseLocksResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Locks/GetInfobaseLocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locksClient) GetSessionLocks(ctx context.Context, in *v1.GetSessionLocksRequest, opts ...grpc.CallOption) (*v1.GetSessionLocksResponse, error) {
	out := new(v1.GetSessionLocksResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Locks/GetSessionLocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *locksClient) GetConnectionLocks(ctx context.Context, in *v1.GetConnectionLocksRequest, opts ...grpc.CallOption) (*v1.GetConnectionLocksResponse, error) {
	out := new(v1.GetConnectionLocksResponse)
	err := c.cc.Invoke(ctx, "/service.api.v1.Locks/GetConnectionLocks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LocksServer is the server API for Locks service.
// All implementations must embed UnimplementedLocksServer
// for forward compatibility
type LocksServer interface {
	GetLocks(context.Context, *v1.GetLocksRequest) (*v1.GetLocksResponse, error)
	GetInfobaseLocks(context.Context, *v1.GetInfobaseLocksRequest) (*v1.GetInfobaseLocksResponse, error)
	GetSessionLocks(context.Context, *v1.GetSessionLocksRequest) (*v1.GetSessionLocksResponse, error)
	GetConnectionLocks(context.Context, *v1.GetConnectionLocksRequest) (*v1.GetConnectionLocksResponse, error)
	mustEmbedUnimplementedLocksServer()
}

// UnimplementedLocksServer must be embedded to have forward compatible implementations.
type UnimplementedLocksServer struct {
}

func (UnimplementedLocksServer) GetLocks(context.Context, *v1.GetLocksRequest) (*v1.GetLocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLocks not implemented")
}
func (UnimplementedLocksServer) GetInfobaseLocks(context.Context, *v1.GetInfobaseLocksRequest) (*v1.GetInfobaseLocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInfobaseLocks not implemented")
}
func (UnimplementedLocksServer) GetSessionLocks(context.Context, *v1.GetSessionLocksRequest) (*v1.GetSessionLocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSessionLocks not implemented")
}
func (UnimplementedLocksServer) GetConnectionLocks(context.Context, *v1.GetConnectionLocksRequest) (*v1.GetConnectionLocksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConnectionLocks not implemented")
}
func (UnimplementedLocksServer) mustEmbedUnimplementedLocksServer() {}

// UnsafeLocksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LocksServer will
// result in compilation errors.
type UnsafeLocksServer interface {
	mustEmbedUnimplementedLocksServer()
}

func RegisterLocksServer(s grpc.ServiceRegistrar, srv LocksServer) {
	s.RegisterService(&Locks_ServiceDesc, srv)
}

func _Locks_GetLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocksServer).GetLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Locks/GetLocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocksServer).GetLocks(ctx, req.(*v1.GetLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Locks_GetInfobaseLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetInfobaseLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocksServer).GetInfobaseLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Locks/GetInfobaseLocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocksServer).GetInfobaseLocks(ctx, req.(*v1.GetInfobaseLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Locks_GetSessionLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetSessionLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocksServer).GetSessionLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Locks/GetSessionLocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocksServer).GetSessionLocks(ctx, req.(*v1.GetSessionLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Locks_GetConnectionLocks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetConnectionLocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LocksServer).GetConnectionLocks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.api.v1.Locks/GetConnectionLocks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LocksServer).GetConnectionLocks(ctx, req.(*v1.GetConnectionLocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Locks_ServiceDesc is the grpc.ServiceDesc for Locks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Locks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.api.v1.Locks",
	HandlerType: (*LocksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLocks",
			Handler:    _Locks_GetLocks_Handler,
		},
		{
			MethodName: "GetInfobaseLocks",
			Handler:    _Locks_GetInfobaseLocks_Handler,
		},
		{
			MethodName: "GetSessionLocks",
			Handler:    _Locks_GetSessionLocks_Handler,
		},
		{
			MethodName: "GetConnectionLocks",
			Handler:    _Locks_GetConnectionLocks_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service/api/v1/ras_api.proto",
}
